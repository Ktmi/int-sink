/* Automatically generated by p4c-xdp from int-sink-xdp.p4 on Tue Aug 31 18:26:38 2021
 * Edited by David Ramirez
 */

#include <linux/types.h>
#include <linux/bpf.h>
#include <bpf/bpf_helpers.h>
#include "helpers/endian.h"
#include "helpers/memory.h"

typedef __u8 u8;
typedef __u16 u16;
typedef __u32 u32;
typedef __u64 u64;

#define ETH_ALEN 6

#define ETH_P_IP 0x0800
#define ETH_P_8021Q	0x8100

struct ethhdr {
	unsigned char	h_dest[ETH_ALEN];	/* destination eth addr	*/
	unsigned char	h_source[ETH_ALEN];	/* source ether addr	*/
	__be16		h_proto;		/* packet type ID field	*/
} __attribute__((packed));

struct ethernet_t {
    struct ethhdr hdr;
    u8 ebpf_valid;
};

struct vlan_hdr {
	__be16	h_vlan_TCI;
	__be16	h_vlan_encapsulated_proto;
};

struct vlan_t {
    struct vlan_hdr hdr;
    u8 ebpf_valid;
};

struct iphdr {
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u8	ihl:4,
		version:4,
        ecn:2,
        dscp:6;
#elif defined (__BIG_ENDIAN_BITFIELD)
	__u8	version:4,
  		ihl:4,
        dscp:6,
        ecn:2;
#else
#error	"Please fix <asm/byteorder.h>"
#endif
	__be16	tot_len;
	__be16	id;
	__be16	frag_off;
	__u8	ttl;
	__u8	protocol;
	__sum16	check;
	__be32	saddr;
	__be32	daddr;
	/*The options start here. */
};

struct ipv4_t {
    struct iphdr hdr;
    u8 ebpf_valid;
};

struct udphdr {
	__be16	source;
	__be16	dest;
	__be16	len;
	__sum16	check;
};


struct udp_t {
    struct udphdr hdr;
    u8 ebpf_valid;
};

struct tcphdr {
	__be16	source;
	__be16	dest;
	__be32	seq;
	__be32	ack_seq;
#if defined(__LITTLE_ENDIAN_BITFIELD)
	__u16	res1:4,
		doff:4,
		fin:1,
		syn:1,
		rst:1,
		psh:1,
		ack:1,
		urg:1,
		ece:1,
		cwr:1;
#elif defined(__BIG_ENDIAN_BITFIELD)
	__u16	doff:4,
		res1:4,
		cwr:1,
		ece:1,
		urg:1,
		ack:1,
		psh:1,
		rst:1,
		syn:1,
		fin:1;
#else
#error	"Adjust your <asm/byteorder.h> defines"
#endif	
	__be16	window;
	__sum16	check;
	__be16	urg_ptr;
};

struct tcp_t {
    struct tcphdr hdr;
    u8 ebpf_valid;
};

struct int10_shim_t
{
    __u8 int_type;
    __u8 rsvd1;
    __u8 len;
#if defined(__BIG_ENDIAN_BITFIELD)
    __u8 DSCP:6,
         rsvd2:2;
#elif defined(__LITTLE_ENDIAN_BITFIELD)
    __u8 rsvd2:2,
         DSCP:6;
#else
#error "Please fix <asm/byteorder.h>"
#endif
};

struct headers {
    struct ethernet_t ethernet; /* ethernet_t */
    struct vlan_t vlan; /* vlan_t */
    struct ipv4_t ipv4; /* ipv4_t */
    struct udp_t udp; /* udp_t */
    struct tcp_t tcp; /* tcp_t */
};

enum ebpf_errorCodes {
    NoError,
    PacketTooShort,
    NoMatch,
    StackOutOfBounds,
    HeaderTooShort,
    ParserTimeout,
    ParserInvalidArgument,
};

#define BYTES(w) ((w) / 8)

inline u16 ebpf_ipv4_checksum(u8 version, u8 ihl, u8 diffserv,
                  u16 totalLen, u16 identification, u8 flags,
                  u16 fragOffset, u8 ttl, u8 protocol,
                  u32 srcAddr, u32 dstAddr) {
    u32 checksum = __bpf_htons(((u16)version << 12) | ((u16)ihl << 8) | (u16)diffserv);
    checksum += __bpf_htons(totalLen);
    checksum += __bpf_htons(identification);
    checksum += __bpf_htons(((u16)flags << 13) | fragOffset);
    checksum += __bpf_htons(((u16)ttl << 8) | (u16)protocol);
    srcAddr = __bpf_ntohl(srcAddr);
    dstAddr = __bpf_ntohl(dstAddr);
    checksum += (srcAddr >> 16) + (u16)srcAddr;
    checksum += (dstAddr >> 16) + (u16)dstAddr;
    // Fields in 'struct Headers' are host byte order.
    // Deparser converts to network byte-order
    return bpf_ntohs(~((checksum & 0xFFFF) + (checksum >> 16)));
}
inline u16 csum16_add(u16 csum, u16 addend) {
    u16 res = csum;
    res += addend;
    return (res + (res < addend));
}
inline u16 csum16_sub(u16 csum, u16 addend) {
    return csum16_add(csum, ~addend);
}
inline u16 csum_replace2(u16 csum, u16 old, u16 new) {
    return (~csum16_add(csum16_sub(~csum, old), new));
}

inline u16 csum_fold(u32 csum) {
    u32 r = csum << 16 | csum >> 16;
    csum = ~csum;
    csum -= r;
    return (u16)(csum >> 16);
}
inline u32 csum_unfold(u16 csum) {
    return (u32)csum;
}
inline u32 csum32_add(u32 csum, u32 addend) {
    u32 res = csum;
    res += addend;
    return (res + (res < addend));
}
inline u32 csum32_sub(u32 csum, u32 addend) {
    return csum32_add(csum, ~addend);
}
inline u16 csum_replace4(u16 csum, u32 from, u32 to) {
    u32 tmp = csum32_sub(~csum_unfold(csum), from);
    return csum_fold(csum32_add(tmp, to));
}

struct {
    __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);
    __uint(key_size, sizeof(__u32));
    __uint(value_size, sizeof(__u32));
} int_perf_event SEC(".maps");

SEC("xdp")
int ebpf_filter(struct xdp_md *ctx){
    struct headers hdr = {
        .ethernet = {
            .ebpf_valid = 0
        },
        .vlan = {
            .ebpf_valid = 0
        },
        .ipv4 = {
            .ebpf_valid = 0
        },
        .udp = {
            .ebpf_valid = 0
        },
        .tcp = {
            .ebpf_valid = 0
        },
    };
    unsigned ebpf_packetOffsetInBytes = 0;
    enum ebpf_errorCodes ebpf_errorCode = NoError;
    void* ebpf_packetStart = ((void*)(long)ctx->data);
    void* ebpf_packetEnd = ((void*)(long)ctx->data_end);
    u32 ebpf_outHeaderLengthInBytes = 0;
    enum xdp_action output_action = XDP_ABORTED;

    goto start;
    parse_ipv4: {
/* extract(hdr.ipv4)*/
        if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.ipv4.hdr)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        memcpy(&hdr.ipv4.hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(hdr.ipv4.hdr));
        ebpf_packetOffsetInBytes += sizeof(hdr.ipv4.hdr);

        hdr.ipv4.ebpf_valid = 1;
        switch (hdr.ipv4.hdr.protocol) {
            case 0x6: goto parse_tcp;
            case 0x11: goto parse_udp;
            default: goto accept;
        }
    }
    parse_tcp: {
/* extract(hdr.tcp)*/
        if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.tcp.hdr)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        memcpy(&hdr.tcp.hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(hdr.tcp.hdr));
        ebpf_packetOffsetInBytes += sizeof(hdr.tcp.hdr);

        hdr.tcp.ebpf_valid = 1;
        goto accept;
    }
    parse_udp: {
/* extract(hdr.udp)*/
        if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.udp.hdr)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }

        memcpy(&hdr.udp.hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(hdr.udp.hdr));
        ebpf_packetOffsetInBytes += sizeof(hdr.udp.hdr);

        hdr.udp.ebpf_valid = 1;
        goto accept;
    }
    parse_vlan: {
/* extract(hdr.vlan)*/
        if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.vlan.hdr)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        memcpy(&hdr.vlan.hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(hdr.vlan.hdr));
        ebpf_packetOffsetInBytes += sizeof(hdr.vlan.hdr);

        hdr.vlan.ebpf_valid = 1;
        switch (hdr.vlan.hdr.h_vlan_encapsulated_proto) {
            case htons(ETH_P_IP): goto parse_ipv4;
            default: goto accept;
        }
    }
    start: {
/* extract(hdr.ethernet)*/
        if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.ethernet.hdr)) {
            ebpf_errorCode = PacketTooShort;
            goto reject;
        }
        memcpy(&hdr.ethernet.hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(hdr.ethernet.hdr));
        ebpf_packetOffsetInBytes += sizeof(hdr.ethernet.hdr);

        hdr.ethernet.ebpf_valid = 1;
        switch (hdr.ethernet.hdr.h_proto) {
            case htons(ETH_P_8021Q): goto parse_vlan;
            case htons(ETH_P_IP): goto parse_ipv4;
            default: goto accept;
        }
    }

    reject: { return XDP_ABORTED; }

    accept:
    {
        u16 int_len_0 = 0;
        u8 new_dscp_0 = 0;
        struct int10_shim_t shim_hdr = {};
        {
if (/* hdr.ipv4.isValid()*/
            hdr.ipv4.ebpf_valid && hdr.ipv4.hdr.dscp == 0x17) {
                bpf_xdp_adjust_head(ctx, ebpf_packetOffsetInBytes);
                ebpf_packetStart = ((void*)(long)ctx->data);
                ebpf_packetEnd = ((void*)(long)ctx->data_end);
                ebpf_packetOffsetInBytes = 0;
                if(ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(shim_hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(&shim_hdr, ebpf_packetStart + ebpf_packetOffsetInBytes, sizeof(shim_hdr));
                int_len_0 = shim_hdr.len * 4;
                new_dscp_0 = shim_hdr.DSCP;
                ebpf_packetOffsetInBytes = int_len_0;
                bpf_perf_event_output(ctx, &int_perf_event, ((u64)int_len_0 << 32) | BPF_F_CURRENT_CPU, &(hdr.ipv4.hdr), sizeof(hdr.ipv4.hdr));
if (/* hdr.udp.isValid()*/
                hdr.udp.ebpf_valid) {
hdr.udp.hdr.len = htons(ntohs(hdr.udp.hdr.len) - int_len_0);
                    hdr.udp.hdr.check = 0;
                }
                hdr.ipv4.hdr.check = /* csum_replace2(hdr.ipv4.check, hdr.ipv4.tot_len, (hdr.ipv4.tot_len - int_len_0))*/
                htons(csum_replace2(ntohs((const u16 ) hdr.ipv4.hdr.check),
                                    ntohs((const u16 ) hdr.ipv4.hdr.tot_len),
                                    ((const u16 ) (ntohs(hdr.ipv4.hdr.tot_len) - int_len_0))));
;
                hdr.ipv4.hdr.tot_len = htons(ntohs(hdr.ipv4.hdr.tot_len) - int_len_0);
                hdr.ipv4.hdr.check = /* csum_replace2(hdr.ipv4.check, (((((u16)hdr.ipv4.version << 12) | ((u16)hdr.ipv4.ihl << 8)) | ((u16)hdr.ipv4.dscp << 2)) | (u16)hdr.ipv4.ecn), (((((u16)hdr.ipv4.version << 12) | ((u16)hdr.ipv4.ihl << 8)) | ((u16)new_dscp_0 << 2)) | (u16)hdr.ipv4.ecn))*/
                htons(csum_replace2(ntohs((const u16 ) hdr.ipv4.hdr.check),
                                    (const u16 ) (((((u16)hdr.ipv4.hdr.version << 12) | ((u16)hdr.ipv4.hdr.ihl << 8)) | ((u16)hdr.ipv4.hdr.dscp << 2)) | (u16)hdr.ipv4.hdr.ecn),
                                    (const u16 ) (((((u16)hdr.ipv4.hdr.version << 12) | ((u16)hdr.ipv4.hdr.ihl << 8)) | ((u16)new_dscp_0 << 2)) | (u16)hdr.ipv4.hdr.ecn)));
;
                hdr.ipv4.hdr.dscp = new_dscp_0;
            }
            output_action = XDP_PASS;
        }
    }
    /* deparser */
    {
        {
if (hdr.ethernet.ebpf_valid) ebpf_outHeaderLengthInBytes += sizeof(hdr.ethernet.hdr);
            if (hdr.vlan.ebpf_valid) ebpf_outHeaderLengthInBytes += sizeof(hdr.vlan.hdr);
            if (hdr.ipv4.ebpf_valid) ebpf_outHeaderLengthInBytes += sizeof(hdr.ipv4.hdr);
            if (hdr.udp.ebpf_valid) ebpf_outHeaderLengthInBytes += sizeof(hdr.udp.hdr);
            if (hdr.tcp.ebpf_valid) ebpf_outHeaderLengthInBytes += sizeof(hdr.tcp.hdr);
        }
        bpf_xdp_adjust_head(ctx, ebpf_packetOffsetInBytes - ebpf_outHeaderLengthInBytes);
        ebpf_packetStart = ((void*)(long)ctx->data);
        ebpf_packetEnd = ((void*)(long)ctx->data_end);
        ebpf_packetOffsetInBytes = 0;
        {
/* packet.emit(hdr.ethernet)*/
            if (hdr.ethernet.ebpf_valid) {
                if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.ethernet.hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(ebpf_packetStart + ebpf_packetOffsetInBytes, &hdr.ethernet.hdr, sizeof(hdr.ethernet.hdr));
                ebpf_packetOffsetInBytes += sizeof(hdr.ethernet.hdr);
            }
;
            /* packet.emit(hdr.vlan)*/
            if (hdr.vlan.ebpf_valid) {
                if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.vlan.hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(ebpf_packetStart + ebpf_packetOffsetInBytes, &hdr.vlan.hdr, sizeof(hdr.vlan.hdr));
                ebpf_packetOffsetInBytes += sizeof(hdr.vlan.hdr);
            }
;
            /* packet.emit(hdr.ipv4)*/
            if (hdr.ipv4.ebpf_valid) {
                if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.ipv4.hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(ebpf_packetStart + ebpf_packetOffsetInBytes, &hdr.ipv4.hdr, sizeof(hdr.ipv4.hdr));
                ebpf_packetOffsetInBytes += sizeof(hdr.ipv4.hdr);
            }
;
            /* packet.emit(hdr.udp)*/
            if (hdr.udp.ebpf_valid) {
                if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.udp.hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(ebpf_packetStart + ebpf_packetOffsetInBytes, &hdr.udp.hdr, sizeof(hdr.udp.hdr));
                ebpf_packetOffsetInBytes += sizeof(hdr.udp.hdr);
            }
;
            /* packet.emit(hdr.tcp)*/
            if (hdr.tcp.ebpf_valid) {
                if (ebpf_packetEnd < ebpf_packetStart + ebpf_packetOffsetInBytes + sizeof(hdr.tcp.hdr)) {
                    ebpf_errorCode = PacketTooShort;
                    return XDP_ABORTED;
                }
                memcpy(ebpf_packetStart + ebpf_packetOffsetInBytes, &hdr.tcp.hdr, sizeof(hdr.tcp.hdr));
                ebpf_packetOffsetInBytes += sizeof(hdr.tcp.hdr);
            }
;
        }
    }
    return output_action;
}
char _license[] SEC("license") = "GPL";
